# -*- coding: utf-8 -*-
"""04_optimization_tool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/166gRFMx-NEXWZZuv2FYlQ0vSahWHYgSQ
"""

"""
=============================================================================
PULTRUSION PROCESS OPTIMIZER - INVERSE DESIGN TOOL
=============================================================================
Given a target cure degree, this tool finds optimal velocity and temperature
combinations to achieve the desired cure while minimizing temperature.

Requirements:
- models_cure.pkl
- models_temp.pkl
=============================================================================
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle
from google.colab import files
from scipy.optimize import minimize, differential_evolution
from scipy.ndimage import gaussian_filter
import warnings
warnings.filterwarnings('ignore')

# Set Times New Roman font
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.serif'] = ['Times New Roman', 'DejaVu Serif', 'Liberation Serif']
plt.rcParams['mathtext.fontset'] = 'stix'

print("=" * 80)
print(" " * 15 + "PULTRUSION PROCESS OPTIMIZER")
print(" " * 18 + "Inverse Design Tool")
print("=" * 80)

# ===== LOAD PRE-TRAINED MODELS =====
print("\nüìÇ Step 1: Loading Pre-Trained Models")
print("-" * 80)

try:
    with open('models_cure.pkl', 'rb') as f:
        models_cure = pickle.load(f)
    with open('models_temp.pkl', 'rb') as f:
        models_temp = pickle.load(f)
    print("‚úì Models loaded successfully!")

except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print(f"‚ö† Model loading issue: {type(e).__name__}")
    print("\nPlease upload 'models_cure.pkl':")
    uploaded_cure = files.upload()
    cure_filename = list(uploaded_cure.keys())[0]

    print("\nPlease upload 'models_temp.pkl':")
    uploaded_temp = files.upload()
    temp_filename = list(uploaded_temp.keys())[0]

    with open(cure_filename, 'rb') as f:
        models_cure = pickle.load(f)
    with open(temp_filename, 'rb') as f:
        models_temp = pickle.load(f)
    print("\n‚úì Models uploaded and loaded successfully!")

# Use best models
cure_model_name = 'Neural Network'
temp_model_name = 'Gradient Boosting'
cure_model, cure_scaler_X, cure_scaler_y = models_cure[cure_model_name]
temp_model, temp_scaler_X, temp_scaler_y = models_temp[temp_model_name]

print(f"\n‚úì Using best models:")
print(f"  ‚Ä¢ Cure: {cure_model_name}")
print(f"  ‚Ä¢ Temp: {temp_model_name}")

# ===== PREDICTION FUNCTIONS =====
def predict_final_cure(velocity, die_temp):
    """Predict final cure degree at 1000mm"""
    X = np.array([[velocity, die_temp, 1000]])
    if cure_scaler_X is not None:
        X_scaled = cure_scaler_X.transform(X)
        pred_scaled = cure_model.predict(X_scaled)
        return cure_scaler_y.inverse_transform(pred_scaled.reshape(-1, 1))[0, 0]
    return cure_model.predict(X)[0]

def predict_max_temp(velocity, die_temp):
    """Predict maximum temperature along the die"""
    distances = np.linspace(0, 1000, 100)
    X = np.array([[velocity, die_temp, d] for d in distances])
    if temp_scaler_X is not None:
        X_scaled = temp_scaler_X.transform(X)
        pred_scaled = temp_model.predict(X_scaled)
        temps = temp_scaler_y.inverse_transform(pred_scaled.reshape(-1, 1)).ravel()
    else:
        temps = temp_model.predict(X)
    return temps.max()

# ===== USER INPUT =====
print("\n" + "=" * 80)
print("‚öôÔ∏è  Step 2: Define Optimization Target & Constraints")
print("=" * 80)

target_cure = float(input("\n‚û§ Enter target cure degree (0-1, e.g., 0.95): "))

print("\nüìè Define parameter ranges (should match training data range):")
print("   ‚ö†Ô∏è  WARNING: Using ranges outside training data may give unreliable results!")
vel_min = float(input("  ‚Ä¢ Minimum velocity (m/min) [e.g., 0.11]: "))
vel_max = float(input("  ‚Ä¢ Maximum velocity (m/min) [e.g., 0.21]: "))
temp_min = float(input("  ‚Ä¢ Minimum die temperature (¬∞C) [e.g., 110]: "))
temp_max = float(input("  ‚Ä¢ Maximum die temperature (¬∞C) [e.g., 140]: "))

print("\nüå°Ô∏è  Temperature constraint:")
temp_limit_option = input("  ‚Ä¢ Set maximum temperature limit? (yes/no): ").lower()
if temp_limit_option in ['yes', 'y']:
    max_temp_limit = float(input("    Enter max temperature limit (¬∞C): "))
else:
    max_temp_limit = None

print("\nüéØ Optimization objective:")
print("  1. Minimize maximum temperature (recommended)")
print("  2. Maximize velocity (faster production)")
print("  3. Minimize die temperature (energy saving)")
objective_choice = input("  ‚Ä¢ Select objective (1-3): ")

# ===== OPTIMIZATION SETUP =====
print("\n" + "=" * 80)
print("üî¨ Step 3: Running Optimization...")
print("=" * 80)

def objective_function(x):
    """
    Objective function to minimize
    x[0] = velocity, x[1] = die_temperature
    """
    velocity, die_temp = x

    # Primary goal: match target cure degree
    cure_pred = predict_final_cure(velocity, die_temp)
    cure_error = (cure_pred - target_cure) ** 2

    # Secondary objectives (weighted)
    if objective_choice == '1':
        # Minimize maximum temperature
        max_temp = predict_max_temp(velocity, die_temp)
        secondary = max_temp * 0.01
    elif objective_choice == '2':
        # Maximize velocity (faster production) = minimize negative velocity
        secondary = -velocity * 100
    else:  # objective_choice == '3'
        # Minimize die temperature (save energy)
        secondary = die_temp * 0.1

    # Combined objective (heavily weight cure accuracy)
    return cure_error * 10000 + secondary

def constraint_cure(x):
    """Constraint: cure degree must be within tolerance"""
    velocity, die_temp = x
    cure_pred = predict_final_cure(velocity, die_temp)
    return abs(cure_pred - target_cure) - 0.005  # ¬±0.5% tolerance

def constraint_max_temp(x):
    """Constraint: maximum temperature must be below limit"""
    if max_temp_limit is None:
        return 1.0  # No constraint
    velocity, die_temp = x
    max_temp = predict_max_temp(velocity, die_temp)
    return max_temp_limit - max_temp

# Set up constraints
constraints = []
if max_temp_limit is not None:
    constraints.append({'type': 'ineq', 'fun': constraint_max_temp})

# Bounds
bounds = [(vel_min, vel_max), (temp_min, temp_max)]

# ===== RUN MULTIPLE OPTIMIZATION METHODS =====
print("\nüîç Finding optimal solutions using multiple methods...")

# Method 1: Differential Evolution (global optimizer)
print("\n  1. Running global optimization (Differential Evolution)...")
result_de = differential_evolution(
    objective_function,
    bounds,
    maxiter=500,
    popsize=30,
    seed=42,
    polish=True,
    atol=1e-6
)

# Method 2: Local optimization from multiple starting points
print("  2. Running local optimizations from multiple starting points...")
best_local_result = None
best_local_score = np.inf

n_starts = 20
for i in range(n_starts):
    x0 = [
        np.random.uniform(vel_min, vel_max),
        np.random.uniform(temp_min, temp_max)
    ]

    try:
        result_local = minimize(
            objective_function,
            x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints,
            options={'ftol': 1e-9}
        )

        if result_local.fun < best_local_score:
            best_local_score = result_local.fun
            best_local_result = result_local
    except:
        continue

# ===== COLLECT SOLUTIONS =====
solutions = []

# Add global solution
if result_de.success:
    vel_opt, temp_opt = result_de.x
    cure_opt = predict_final_cure(vel_opt, temp_opt)
    max_temp_opt = predict_max_temp(vel_opt, temp_opt)

    solutions.append({
        'Method': 'Global (DE)',
        'Velocity (m/min)': vel_opt,
        'Die Temperature (¬∞C)': temp_opt,
        'Final Cure': cure_opt,
        'Cure Error (%)': abs(cure_opt - target_cure) * 100,
        'Max Temperature (¬∞C)': max_temp_opt,
        'Objective Score': result_de.fun
    })

# Add best local solution
if best_local_result is not None and best_local_result.success:
    vel_opt, temp_opt = best_local_result.x
    cure_opt = predict_final_cure(vel_opt, temp_opt)
    max_temp_opt = predict_max_temp(vel_opt, temp_opt)

    solutions.append({
        'Method': 'Local (SLSQP)',
        'Velocity (m/min)': vel_opt,
        'Die Temperature (¬∞C)': temp_opt,
        'Final Cure': cure_opt,
        'Cure Error (%)': abs(cure_opt - target_cure) * 100,
        'Max Temperature (¬∞C)': max_temp_opt,
        'Objective Score': best_local_result.fun
    })

# ===== GRID SEARCH FOR VISUALIZATION =====
print("  3. Exploring design space (grid search)...")
print("     ‚ö†Ô∏è  Note: ML predictions between training points may have uncertainty")

vel_grid = np.linspace(vel_min, vel_max, 50)
temp_grid = np.linspace(temp_min, temp_max, 50)
VEL, TEMP = np.meshgrid(vel_grid, temp_grid)

CURE = np.zeros_like(VEL)
MAX_TEMP = np.zeros_like(VEL)

for i in range(len(temp_grid)):
    for j in range(len(vel_grid)):
        CURE[i, j] = predict_final_cure(VEL[i, j], TEMP[i, j])
        MAX_TEMP[i, j] = predict_max_temp(VEL[i, j], TEMP[i, j])

# Apply smoothing to reduce interpolation artifacts
from scipy.ndimage import gaussian_filter
CURE_smooth = gaussian_filter(CURE, sigma=1.5)
MAX_TEMP_smooth = gaussian_filter(MAX_TEMP, sigma=1.5)

# ===== FIND FEASIBLE SOLUTIONS =====
# Find all points within tolerance (using smoothed data for more robust feasibility)
tolerance = 0.005  # ¬±0.5%
feasible_mask = np.abs(CURE_smooth - target_cure) <= tolerance

if max_temp_limit is not None:
    feasible_mask = feasible_mask & (MAX_TEMP_smooth <= max_temp_limit)

feasible_count = np.sum(feasible_mask)

# ===== DISPLAY RESULTS =====
print("\n" + "=" * 80)
print("üìä OPTIMIZATION RESULTS")
print("=" * 80)

print(f"\nüéØ Target: Cure Degree = {target_cure:.4f}")
print(f"üìè Constraints:")
print(f"   ‚Ä¢ Velocity: {vel_min:.3f} - {vel_max:.3f} m/min")
print(f"   ‚Ä¢ Die Temperature: {temp_min:.0f} - {temp_max:.0f}¬∞C")
if max_temp_limit:
    print(f"   ‚Ä¢ Max Temperature Limit: {max_temp_limit:.0f}¬∞C")

if solutions:
    print("\n" + "-" * 80)
    print("üèÜ OPTIMAL SOLUTIONS")
    print("-" * 80)

    solutions_df = pd.DataFrame(solutions)
    print(solutions_df.to_string(index=False))

    # Best solution
    best_idx = solutions_df['Objective Score'].idxmin()
    best_sol = solutions_df.iloc[best_idx]

    print("\n" + "=" * 80)
    print("‚ú® RECOMMENDED SOLUTION")
    print("=" * 80)
    print(f"\nüîß Operating Conditions:")
    print(f"   ‚Ä¢ Velocity: {best_sol['Velocity (m/min)']:.4f} m/min")
    print(f"   ‚Ä¢ Die Temperature: {best_sol['Die Temperature (¬∞C)']:.2f}¬∞C")
    print(f"\nüìä Predicted Performance:")
    print(f"   ‚Ä¢ Final Cure Degree: {best_sol['Final Cure']:.6f} ({best_sol['Final Cure']*100:.2f}%)")
    print(f"   ‚Ä¢ Cure Error: ¬±{best_sol['Cure Error (%)']:.3f}%")
    print(f"   ‚Ä¢ Maximum Temperature: {best_sol['Max Temperature (¬∞C)']:.2f}¬∞C")

    if feasible_count > 0:
        print(f"\n‚úì Found {feasible_count} feasible parameter combinations in design space")
else:
    print("\n‚ö† No optimal solution found within constraints!")
    print("   Try relaxing constraints or adjusting target cure degree.")

# ===== VISUALIZATION =====
print("\n" + "=" * 80)
print("üìà Step 4: Creating Design Space Visualization...")
print("=" * 80)

fig = plt.figure(figsize=(20, 12))

# Plot 1: Cure Degree Contours
ax1 = plt.subplot(2, 3, 1)
contour1 = ax1.contourf(VEL, TEMP, CURE_smooth, levels=30, cmap='RdYlGn')
contour1_lines = ax1.contour(VEL, TEMP, CURE_smooth, levels=[target_cure], colors='red', linewidths=3)
ax1.clabel(contour1_lines, inline=True, fontsize=10, fmt=f'{target_cure:.3f}')
cbar1 = plt.colorbar(contour1, ax=ax1)
cbar1.set_label('Cure Degree', fontsize=11)

# Mark feasible region
if feasible_count > 0:
    ax1.contour(VEL, TEMP, feasible_mask.astype(int), levels=[0.5], colors='blue', linewidths=2, linestyles='--')

# Mark optimal solutions
for sol in solutions:
    ax1.scatter(sol['Velocity (m/min)'], sol['Die Temperature (¬∞C)'],
                s=300, c='white', marker='*', edgecolors='black', linewidths=2, zorder=10)

ax1.set_xlabel('Velocity (m/min)', fontsize=12)
ax1.set_ylabel('Die Temperature (¬∞C)', fontsize=12)
ax1.set_title(f'Cure Degree Map (ML Smoothed)\n(Target: {target_cure:.3f})', fontsize=13, fontweight='bold')
ax1.grid(True, alpha=0.3)

# Plot 2: Maximum Temperature Contours
ax2 = plt.subplot(2, 3, 2)
contour2 = ax2.contourf(VEL, TEMP, MAX_TEMP_smooth, levels=30, cmap='hot_r')
contour2_lines = ax2.contour(VEL, TEMP, MAX_TEMP_smooth, levels=10, colors='black', linewidths=0.5, alpha=0.5)
ax2.clabel(contour2_lines, inline=True, fontsize=9, fmt='%.1f')
cbar2 = plt.colorbar(contour2, ax=ax2)
cbar2.set_label('Max Temperature (¬∞C)', fontsize=11)

# Mark temperature limit
if max_temp_limit:
    ax2.contour(VEL, TEMP, MAX_TEMP_smooth, levels=[max_temp_limit], colors='red', linewidths=3, linestyles='--')

# Mark feasible region
if feasible_count > 0:
    ax2.contour(VEL, TEMP, feasible_mask.astype(int), levels=[0.5], colors='blue', linewidths=2, linestyles='--')

# Mark optimal solutions
for sol in solutions:
    ax2.scatter(sol['Velocity (m/min)'], sol['Die Temperature (¬∞C)'],
                s=300, c='white', marker='*', edgecolors='black', linewidths=2, zorder=10)

ax2.set_xlabel('Velocity (m/min)', fontsize=12)
ax2.set_ylabel('Die Temperature (¬∞C)', fontsize=12)
ax2.set_title('Maximum Temperature Map', fontsize=13, fontweight='bold')
ax2.grid(True, alpha=0.3)

# Plot 3: Feasible Region
ax3 = plt.subplot(2, 3, 3)
ax3.contourf(VEL, TEMP, feasible_mask.astype(float), levels=[0, 0.5, 1], colors=['lightcoral', 'lightgreen'], alpha=0.6)
ax3.contour(VEL, TEMP, CURE_smooth, levels=20, colors='gray', linewidths=0.5, alpha=0.3)
ax3.contour(VEL, TEMP, CURE_smooth, levels=[target_cure], colors='red', linewidths=2)

# Mark optimal solutions
for sol in solutions:
    ax3.scatter(sol['Velocity (m/min)'], sol['Die Temperature (¬∞C)'],
                s=300, c='gold', marker='*', edgecolors='black', linewidths=2, zorder=10,
                label='Optimal')

ax3.set_xlabel('Velocity (m/min)', fontsize=12)
ax3.set_ylabel('Die Temperature (¬∞C)', fontsize=12)
ax3.set_title(f'Feasible Design Space\n(Green = Acceptable)', fontsize=13, fontweight='bold')
ax3.grid(True, alpha=0.3)
ax3.legend(fontsize=10)

# Plot 4: Cure Error Map
ax4 = plt.subplot(2, 3, 4)
cure_error = np.abs(CURE_smooth - target_cure) * 100
contour4 = ax4.contourf(VEL, TEMP, cure_error, levels=20, cmap='RdYlGn_r')
cbar4 = plt.colorbar(contour4, ax=ax4)
cbar4.set_label('Cure Error (%)', fontsize=11)

for sol in solutions:
    ax4.scatter(sol['Velocity (m/min)'], sol['Die Temperature (¬∞C)'],
                s=300, c='white', marker='*', edgecolors='black', linewidths=2, zorder=10)

ax4.set_xlabel('Velocity (m/min)', fontsize=12)
ax4.set_ylabel('Die Temperature (¬∞C)', fontsize=12)
ax4.set_title('Cure Degree Error Map', fontsize=13, fontweight='bold')
ax4.grid(True, alpha=0.3)

# Plot 5: Trade-off Analysis
if feasible_count > 0:
    ax5 = plt.subplot(2, 3, 5)

    # Extract feasible points
    feasible_vel = VEL[feasible_mask]
    feasible_temp = TEMP[feasible_mask]
    feasible_max_temp = MAX_TEMP_smooth[feasible_mask]

    scatter = ax5.scatter(feasible_vel, feasible_max_temp, c=feasible_temp,
                         s=50, cmap='coolwarm', alpha=0.6, edgecolors='black', linewidths=0.5)
    cbar5 = plt.colorbar(scatter, ax=ax5)
    cbar5.set_label('Die Temperature (¬∞C)', fontsize=11)

    # Mark optimal solutions
    for sol in solutions:
        ax5.scatter(sol['Velocity (m/min)'], sol['Max Temperature (¬∞C)'],
                    s=300, c='gold', marker='*', edgecolors='black', linewidths=2, zorder=10)

    ax5.set_xlabel('Velocity (m/min)', fontsize=12)
    ax5.set_ylabel('Maximum Temperature (¬∞C)', fontsize=12)
    ax5.set_title('Velocity vs Max Temperature Trade-off', fontsize=13, fontweight='bold')
    ax5.grid(True, alpha=0.3)

# Plot 6: Summary Information
ax6 = plt.subplot(2, 3, 6)
ax6.axis('off')

summary_text = f"OPTIMIZATION SUMMARY\n{'=' * 40}\n\n"
summary_text += f"Target Cure Degree: {target_cure:.4f}\n\n"

if solutions:
    summary_text += f"{'RECOMMENDED SOLUTION'}\n{'-' * 40}\n"
    summary_text += f"Velocity: {best_sol['Velocity (m/min)']:.4f} m/min\n"
    summary_text += f"Die Temp: {best_sol['Die Temperature (¬∞C)']:.2f}¬∞C\n\n"
    summary_text += f"Final Cure: {best_sol['Final Cure']:.6f}\n"
    summary_text += f"Error: ¬±{best_sol['Cure Error (%)']:.3f}%\n"
    summary_text += f"Max Temp: {best_sol['Max Temperature (¬∞C)']:.2f}¬∞C\n\n"
    summary_text += f"{'-' * 40}\n"
    summary_text += f"Feasible Solutions: {feasible_count}\n\n"
    summary_text += f"Note: Gaussian smoothing applied\nto reduce ML interpolation noise"
else:
    summary_text += "No optimal solution found!\n"

ax6.text(0.1, 0.5, summary_text, fontsize=11, family='monospace',
         verticalalignment='center', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

plt.tight_layout()
filename = f'optimization_target{target_cure:.3f}'
plt.savefig(f'{filename}.png', dpi=600, bbox_inches='tight', facecolor='white')
plt.savefig(f'{filename}.pdf', dpi=600, bbox_inches='tight', facecolor='white')
plt.show()

print(f"\n‚úì Visualization saved as '{filename}.png' and '{filename}.pdf'")

# ===== EXPORT RESULTS =====
if solutions:
    excel_filename = f'{filename}_results.xlsx'

    with pd.ExcelWriter(excel_filename, engine='openpyxl') as writer:
        solutions_df.to_excel(writer, sheet_name='Optimal_Solutions', index=False)

        if feasible_count > 0:
            feasible_df = pd.DataFrame({
                'Velocity (m/min)': VEL[feasible_mask],
                'Die Temperature (¬∞C)': TEMP[feasible_mask],
                'Cure Degree': CURE_smooth[feasible_mask],
                'Max Temperature (¬∞C)': MAX_TEMP_smooth[feasible_mask]
            })
            feasible_df.to_excel(writer, sheet_name='All_Feasible_Solutions', index=False)

    print(f"‚úì Results exported to '{excel_filename}'")

print("\n" + "=" * 80)
print("‚úÖ OPTIMIZATION COMPLETE!")
print("=" * 80)
print("\nGenerated files:")
print(f"  ‚Ä¢ {filename}.png (600 dpi)")
print(f"  ‚Ä¢ {filename}.pdf (vector)")
if solutions:
    print(f"  ‚Ä¢ {excel_filename}")
print("\n" + "=" * 80)