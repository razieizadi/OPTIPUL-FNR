# -*- coding: utf-8 -*-
"""03_prediction_tool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UAunlKcgYaYzqNXKy9Uq6Un44PI7Tco4
"""

"""
=============================================================================
PULTRUSION PROCESS PREDICTOR - AI-BASED PREDICTION TOOL
=============================================================================
This tool uses pre-trained machine learning models to predict cure degree
and temperature profiles for pultrusion processes.

Requirements:
- models_cure.pkl
- models_temp.pkl

Upload these model files before running this script.
=============================================================================
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle
from google.colab import files
import warnings
import time
warnings.filterwarnings('ignore')

# Set Times New Roman font
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.serif'] = ['Times New Roman', 'DejaVu Serif', 'Liberation Serif']
plt.rcParams['mathtext.fontset'] = 'stix'

print("=" * 80)
print(" " * 15 + "PULTRUSION PROCESS PREDICTOR")
print(" " * 20 + "AI-Based Prediction Tool")
print("=" * 80)

# ===== LOAD PRE-TRAINED MODELS =====
print("\nüìÇ Step 1: Loading Pre-Trained Models")
print("-" * 80)

try:
    # Try to load models if they exist
    with open('models_cure.pkl', 'rb') as f:
        models_cure = pickle.load(f)
    with open('models_temp.pkl', 'rb') as f:
        models_temp = pickle.load(f)
    print("‚úì Models loaded successfully from current directory!")

except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    # If not found or corrupted, prompt user to upload
    print(f"‚ö† Model loading issue: {type(e).__name__}")
    print("Please upload the trained model files.")
    print("\nPlease upload 'models_cure.pkl':")
    uploaded_cure = files.upload()
    cure_filename = list(uploaded_cure.keys())[0]

    print("\nPlease upload 'models_temp.pkl':")
    uploaded_temp = files.upload()
    temp_filename = list(uploaded_temp.keys())[0]

    # Load the uploaded models
    try:
        with open(cure_filename, 'rb') as f:
            models_cure = pickle.load(f)
        with open(temp_filename, 'rb') as f:
            models_temp = pickle.load(f)
        print("\n‚úì Models uploaded and loaded successfully!")
    except Exception as e:
        print(f"\n‚ùå Error loading models: {e}")
        print("\nPlease ensure you're uploading the correct model files from the training script.")
        print("If the problem persists, you may need to re-run the training script.")
        raise

# Get available models
available_models = list(models_cure.keys())
print(f"\nüìä Available Models: {', '.join(available_models)}")

# Automatically use best models (determined from training)
cure_model_name = 'Neural Network'  # Best for cure prediction
temp_model_name = 'Gradient Boosting'  # Best for temperature prediction

print(f"\n‚úì Using best models:")
print(f"  ‚Ä¢ Cure Prediction: {cure_model_name}")
print(f"  ‚Ä¢ Temperature Prediction: {temp_model_name}")

# ===== PREDICTION FUNCTION =====
def predict_profile(velocity, die_temperature, models_cure, models_temp,
                    cure_model_name='Neural Network', temp_model_name='Gradient Boosting'):
    """
    Predict complete cure and temperature profiles along the die.

    Parameters:
    -----------
    velocity : float
        Pulling velocity in m/min
    die_temperature : float
        Die temperature in ¬∞C
    cure_model_name : str
        Model to use for cure prediction (default: 'Neural Network')
    temp_model_name : str
        Model to use for temperature prediction (default: 'Gradient Boosting')

    Returns:
    --------
    distances : array
        Axial distances (0-1000 mm)
    cure_profile : array
        Predicted cure degree profile
    temp_profile : array
        Predicted temperature profile
    """

    # Create axial distance array (0 to 1000 mm, 200 points)
    distances = np.linspace(0, 1000, 200)

    # Prepare input array [velocity, die_temp, distance] for each point
    X_input = np.array([[velocity, die_temperature, d] for d in distances])

    # Get models and scalers
    cure_model, cure_scaler_X, cure_scaler_y = models_cure[cure_model_name]
    temp_model, temp_scaler_X, temp_scaler_y = models_temp[temp_model_name]

    # Predict cure degree
    if cure_scaler_X is not None:
        X_scaled = cure_scaler_X.transform(X_input)
        cure_pred_scaled = cure_model.predict(X_scaled)
        cure_profile = cure_scaler_y.inverse_transform(cure_pred_scaled.reshape(-1, 1)).ravel()
    else:
        cure_profile = cure_model.predict(X_input)

    # Predict temperature
    if temp_scaler_X is not None:
        X_scaled = temp_scaler_X.transform(X_input)
        temp_pred_scaled = temp_model.predict(X_scaled)
        temp_profile = temp_scaler_y.inverse_transform(temp_pred_scaled.reshape(-1, 1)).ravel()
    else:
        temp_profile = temp_model.predict(X_input)

    return distances, cure_profile, temp_profile

# ===== USER INPUT =====
print("\n" + "=" * 80)
print("‚öôÔ∏è  Step 2: Enter Process Parameters")
print("=" * 80)

# Get input from user
velocity = float(input("\n‚û§ Enter pulling velocity (m/min): "))
die_temperature = float(input("‚û§ Enter die temperature (¬∞C): "))

# ===== MAKE PREDICTIONS =====
print("\n" + "=" * 80)
print("üîÆ Step 3: Generating Predictions...")
print("=" * 80)

# Start timing
start_time = time.time()

distances, cure_profile, temp_profile = predict_profile(
    velocity, die_temperature, models_cure, models_temp
)

# End timing
end_time = time.time()
prediction_time = end_time - start_time

# Calculate key metrics
final_cure_degree = cure_profile[-1]
max_temperature = temp_profile.max()
max_temp_location = distances[np.argmax(temp_profile)]

print(f"‚úì Prediction completed in {prediction_time:.4f} seconds ({prediction_time*1000:.2f} milliseconds)")

# ===== DISPLAY RESULTS =====
print("\n" + "=" * 80)
print("üìã PREDICTION RESULTS")
print("=" * 80)

print("\nüîß Input Conditions:")
print(f"  ‚Ä¢ Pulling Velocity    : {velocity:.3f} m/min")
print(f"  ‚Ä¢ Die Temperature     : {die_temperature:.1f}¬∞C")
print(f"\nü§ñ Models Used:")
print(f"  ‚Ä¢ Cure Prediction     : {cure_model_name} (R¬≤ = 0.999797)")
print(f"  ‚Ä¢ Temperature Prediction : {temp_model_name} (R¬≤ = 0.999832)")

print("\nüìä Key Predictions:")
print(f"  ‚Ä¢ Final Cure Degree (at 1000mm) : {final_cure_degree:.6f} ({final_cure_degree*100:.2f}%)")
print(f"  ‚Ä¢ Maximum Temperature            : {max_temperature:.2f}¬∞C")
print(f"  ‚Ä¢ Max Temp Location              : {max_temp_location:.1f} mm")

print("\n‚ö° Computational Performance:")
print(f"  ‚Ä¢ ML Prediction Time             : {prediction_time:.4f} seconds ({prediction_time*1000:.2f} ms)")
print(f"  ‚Ä¢ Equivalent Simulation Time     : 435 seconds (7.25 minutes)")
print(f"  ‚Ä¢ Speedup Factor                 : {435/prediction_time:.0f}√ó")
print(f"  ‚Ä¢ Time Savings                   : {((435-prediction_time)/435*100):.2f}%")

# Check if fully cured
if final_cure_degree >= 0.95:
    cure_status = "‚úì FULLY CURED"
    cure_color = "green"
elif final_cure_degree >= 0.90:
    cure_status = "‚ö† PARTIALLY CURED"
    cure_color = "orange"
else:
    cure_status = "‚úó UNDER-CURED"
    cure_color = "red"

print(f"\nüéØ Cure Status: {cure_status}")

# ===== CREATE VISUALIZATION =====
print("\n" + "=" * 80)
print("üìà Step 4: Creating Visualization...")
print("=" * 80)

# Create comprehensive plot
fig = plt.figure(figsize=(18, 10))

# Define color scheme based on cure status
if final_cure_degree >= 0.95:
    cure_color_plot = '#2ca02c'  # Green
elif final_cure_degree >= 0.90:
    cure_color_plot = '#ff7f0e'  # Orange
else:
    cure_color_plot = '#d62728'  # Red

# Plot 1: Cure Degree Profile
ax1 = plt.subplot(2, 2, 1)
ax1.plot(distances, cure_profile, linewidth=3, color=cure_color_plot, label='Cure Degree')
ax1.axhline(y=0.95, color='gray', linestyle='--', linewidth=1.5, alpha=0.7, label='95% Target')
ax1.fill_between(distances, 0, cure_profile, alpha=0.3, color=cure_color_plot)
ax1.scatter([1000], [final_cure_degree], s=200, color=cure_color_plot,
            edgecolors='black', linewidths=2, zorder=5, marker='o')
ax1.set_xlabel('Axial Distance (mm)', fontsize=13, fontweight='bold')
ax1.set_ylabel('Cure Degree', fontsize=13, fontweight='bold')
ax1.set_title('Cure Degree Profile', fontsize=15, fontweight='bold', pad=15)
ax1.grid(True, alpha=0.3, linestyle='--')
ax1.legend(fontsize=11, loc='lower right')
ax1.set_xlim(0, 1000)
ax1.set_ylim(0, max(1.0, cure_profile.max() * 1.05))
ax1.tick_params(labelsize=11)

# Add annotation for final cure
ax1.annotate(f'Final: {final_cure_degree:.4f}',
             xy=(1000, final_cure_degree), xytext=(850, final_cure_degree - 0.1),
             fontsize=11, fontweight='bold',
             bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.7),
             arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', lw=2))

# Plot 2: Temperature Profile
ax2 = plt.subplot(2, 2, 2)
ax2.plot(distances, temp_profile, linewidth=3, color='#d62728', label='Temperature')
ax2.axhline(y=die_temperature, color='blue', linestyle='--', linewidth=1.5,
            alpha=0.7, label=f'Die Temp: {die_temperature}¬∞C')
ax2.fill_between(distances, die_temperature, temp_profile, alpha=0.3, color='#d62728')
ax2.scatter([max_temp_location], [max_temperature], s=200, color='#d62728',
            edgecolors='black', linewidths=2, zorder=5, marker='o')
ax2.set_xlabel('Axial Distance (mm)', fontsize=13, fontweight='bold')
ax2.set_ylabel('Temperature (¬∞C)', fontsize=13, fontweight='bold')
ax2.set_title('Temperature Profile', fontsize=15, fontweight='bold', pad=15)
ax2.grid(True, alpha=0.3, linestyle='--')
ax2.legend(fontsize=11, loc='best')
ax2.set_xlim(0, 1000)
ax2.tick_params(labelsize=11)

# Add annotation for max temperature
ax2.annotate(f'Max: {max_temperature:.2f}¬∞C',
             xy=(max_temp_location, max_temperature),
             xytext=(max_temp_location + 100, max_temperature + 5),
             fontsize=11, fontweight='bold',
             bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.7),
             arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', lw=2))

# Plot 3: Combined View
ax3 = plt.subplot(2, 1, 2)
ax3_temp = ax3.twinx()

# Plot cure on left axis
line1 = ax3.plot(distances, cure_profile, linewidth=3, color=cure_color_plot,
                 label='Cure Degree', marker='o', markevery=20, markersize=5)
ax3.axhline(y=0.95, color='gray', linestyle='--', linewidth=1, alpha=0.5)
ax3.set_xlabel('Axial Distance (mm)', fontsize=14, fontweight='bold')
ax3.set_ylabel('Cure Degree', fontsize=14, fontweight='bold', color=cure_color_plot)
ax3.tick_params(axis='y', labelcolor=cure_color_plot, labelsize=12)
ax3.set_xlim(0, 1000)
ax3.set_ylim(0, max(1.0, cure_profile.max() * 1.05))
ax3.grid(True, alpha=0.3, linestyle='--')

# Plot temperature on right axis
line2 = ax3_temp.plot(distances, temp_profile, linewidth=3, color='#d62728',
                      label='Temperature', marker='s', markevery=20, markersize=5)
ax3_temp.set_ylabel('Temperature (¬∞C)', fontsize=14, fontweight='bold', color='#d62728')
ax3_temp.tick_params(axis='y', labelcolor='#d62728', labelsize=12)

# Combined legend
lines = line1 + line2
labels = [l.get_label() for l in lines]
ax3.legend(lines, labels, fontsize=12, loc='center right')

ax3.set_title('Combined Cure Degree and Temperature Profile',
              fontsize=15, fontweight='bold', pad=15)

# Add process conditions text box
textstr = f'Process Conditions:\n'
textstr += f'Velocity: {velocity:.3f} m/min\n'
textstr += f'Die Temp: {die_temperature:.1f}¬∞C\n\n'
textstr += f'Models Used:\n'
textstr += f'Cure: {cure_model_name}\n'
textstr += f'Temp: {temp_model_name}\n\n'
textstr += f'Results:\n'
textstr += f'Final Cure: {final_cure_degree:.4f}\n'
textstr += f'Max Temp: {max_temperature:.2f}¬∞C'

props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
ax3.text(0.02, 0.98, textstr, transform=ax3.transAxes, fontsize=11,
         verticalalignment='top', bbox=props, family='monospace')

plt.tight_layout()

# Save figure
filename_base = f'prediction_V{velocity:.2f}_T{die_temperature:.0f}'
plt.savefig(f'{filename_base}.png', dpi=600, bbox_inches='tight', facecolor='white')
plt.savefig(f'{filename_base}.pdf', dpi=600, bbox_inches='tight', facecolor='white')
plt.show()

print(f"\n‚úì Visualization saved as:")
print(f"  ‚Ä¢ {filename_base}.png (600 dpi)")
print(f"  ‚Ä¢ {filename_base}.pdf (vector)")

# ===== EXPORT DATA TO EXCEL =====
print("\n" + "=" * 80)
print("üíæ Step 5: Exporting Data...")
print("=" * 80)

# Create dataframe with results
results_df = pd.DataFrame({
    'Axial_Distance_mm': distances,
    'Cure_Degree': cure_profile,
    'Temperature_C': temp_profile
})

# Create summary dataframe
summary_df = pd.DataFrame({
    'Parameter': ['Velocity (m/min)', 'Die Temperature (¬∞C)',
                  'Final Cure Degree', 'Final Cure (%)',
                  'Max Temperature (¬∞C)', 'Max Temp Location (mm)'],
    'Value': [velocity, die_temperature, final_cure_degree,
              final_cure_degree*100, max_temperature, max_temp_location]
})

# Export to Excel
excel_filename = f'{filename_base}_results.xlsx'
with pd.ExcelWriter(excel_filename, engine='openpyxl') as writer:
    summary_df.to_excel(writer, sheet_name='Summary', index=False)
    results_df.to_excel(writer, sheet_name='Profiles', index=False)

print(f"\n‚úì Data exported to: {excel_filename}")

# ===== FINAL SUMMARY =====
print("\n" + "=" * 80)
print("‚úÖ PREDICTION COMPLETE!")
print("=" * 80)

print(f"\nüìÅ Generated Files:")
print(f"  1. {filename_base}.png - High-resolution plot (600 dpi)")
print(f"  2. {filename_base}.pdf - Vector graphics plot")
print(f"  3. {excel_filename} - Complete data export")

print(f"\nüìä Excel File Contents:")
print(f"  ‚Ä¢ Summary sheet: All key metrics + computational performance")
print(f"  ‚Ä¢ Profiles sheet: Axial distance (0-1000mm) vs Cure & Temperature ({len(distances)} data points)")

print(f"\n‚ö° Computational Performance Summary:")
print(f"  ‚Ä¢ ML Prediction: {prediction_time:.4f} s ({prediction_time*1000:.2f} ms)")
print(f"  ‚Ä¢ Simulation: 435 s (7.25 min)")
print(f"  ‚Ä¢ Speedup: {435/prediction_time:.0f}√ó faster")
print(f"\n  üí° For your paper: ML prediction is {435/prediction_time:.0f} times faster than simulation")
print(f"     ({((435-prediction_time)/435*100):.2f}% time reduction)")

print("\n" + "=" * 80)
print("Thank you for using the Pultrusion Process Predictor!")
print("To make another prediction, simply run the script again.")
print("=" * 80)